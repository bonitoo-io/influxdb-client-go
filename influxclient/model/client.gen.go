// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package model

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HTTPRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HTTPRequestDoer
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, doer HTTPRequestDoer) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: doer,
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

func (e *Error) Error() error {
	return fmt.Errorf("%s: %s", string(e.Code), e.Message)
}

func unmarshalJSONResponse(bodyBytes []byte, obj interface{}) error {
	if err := json.Unmarshal(bodyBytes, obj); err != nil {
		return err
	}
	return nil
}

func isJSON(rsp *http.Response) bool {
	return rsp.Header.Get("Content-Type") == "application/json"
}

func newUnexpectedResponseError(rsp *http.Response) error {
	return fmt.Errorf("unexpected content-type: %v", rsp.Header.Get("Content-Type"))
}

// GetAuthorizations calls the GET on /authorizations
func (c *Client) GetAuthorizations(ctx context.Context, params *GetAuthorizationsParams) (*Authorizations, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userID", runtime.ParamLocationQuery, *params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorizations{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostAuthorizations calls the POST on /authorizations
func (c *Client) PostAuthorizations(ctx context.Context, params *PostAuthorizationsAllParams) (*Authorization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteAuthorizationsID calls the DELETE on /authorizations/{authID}
func (c *Client) DeleteAuthorizationsID(ctx context.Context, params *DeleteAuthorizationsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetAuthorizationsID calls the GET on /authorizations/{authID}
func (c *Client) GetAuthorizationsID(ctx context.Context, params *GetAuthorizationsIDAllParams) (*Authorization, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchAuthorizationsID calls the PATCH on /authorizations/{authID}
func (c *Client) PatchAuthorizationsID(ctx context.Context, params *PatchAuthorizationsIDAllParams) (*Authorization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetBuckets calls the GET on /buckets
func (c *Client) GetBuckets(ctx context.Context, params *GetBucketsParams) (*Buckets, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Buckets{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostBuckets calls the POST on /buckets
func (c *Client) PostBuckets(ctx context.Context, params *PostBucketsAllParams) (*Bucket, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Bucket{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteBucketsID calls the DELETE on /buckets/{bucketID}
func (c *Client) DeleteBucketsID(ctx context.Context, params *DeleteBucketsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/buckets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetBucketsID calls the GET on /buckets/{bucketID}
func (c *Client) GetBucketsID(ctx context.Context, params *GetBucketsIDAllParams) (*Bucket, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Bucket{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchBucketsID calls the PATCH on /buckets/{bucketID}
func (c *Client) PatchBucketsID(ctx context.Context, params *PatchBucketsIDAllParams) (*Bucket, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Bucket{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetBucketsIDLabels calls the GET on /buckets/{bucketID}/labels
func (c *Client) GetBucketsIDLabels(ctx context.Context, params *GetBucketsIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostBucketsIDLabels calls the POST on /buckets/{bucketID}/labels
func (c *Client) PostBucketsIDLabels(ctx context.Context, params *PostBucketsIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteBucketsIDLabelsID calls the DELETE on /buckets/{bucketID}/labels/{labelID}
func (c *Client) DeleteBucketsIDLabelsID(ctx context.Context, params *DeleteBucketsIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/buckets/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetBucketsIDMembers calls the GET on /buckets/{bucketID}/members
func (c *Client) GetBucketsIDMembers(ctx context.Context, params *GetBucketsIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostBucketsIDMembers calls the POST on /buckets/{bucketID}/members
func (c *Client) PostBucketsIDMembers(ctx context.Context, params *PostBucketsIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteBucketsIDMembersID calls the DELETE on /buckets/{bucketID}/members/{userID}
func (c *Client) DeleteBucketsIDMembersID(ctx context.Context, params *DeleteBucketsIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/buckets/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetBucketsIDOwners calls the GET on /buckets/{bucketID}/owners
func (c *Client) GetBucketsIDOwners(ctx context.Context, params *GetBucketsIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostBucketsIDOwners calls the POST on /buckets/{bucketID}/owners
func (c *Client) PostBucketsIDOwners(ctx context.Context, params *PostBucketsIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buckets/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteBucketsIDOwnersID calls the DELETE on /buckets/{bucketID}/owners/{userID}
func (c *Client) DeleteBucketsIDOwnersID(ctx context.Context, params *DeleteBucketsIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bucketID", runtime.ParamLocationPath, params.BucketID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/buckets/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetChecks calls the GET on /checks
func (c *Client) GetChecks(ctx context.Context, params *GetChecksParams) (*Checks, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, params.OrgID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Checks{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// CreateCheck calls the POST on /checks
func (c *Client) CreateCheck(ctx context.Context, params *CreateCheckAllParams) (*Check, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Check{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteChecksID calls the DELETE on /checks/{checkID}
func (c *Client) DeleteChecksID(ctx context.Context, params *DeleteChecksIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/checks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetChecksID calls the GET on /checks/{checkID}
func (c *Client) GetChecksID(ctx context.Context, params *GetChecksIDAllParams) (*Check, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Check{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchChecksID calls the PATCH on /checks/{checkID}
func (c *Client) PatchChecksID(ctx context.Context, params *PatchChecksIDAllParams) (*Check, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Check{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutChecksID calls the PUT on /checks/{checkID}
func (c *Client) PutChecksID(ctx context.Context, params *PutChecksIDAllParams) (*Check, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Check{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetChecksIDLabels calls the GET on /checks/{checkID}/labels
func (c *Client) GetChecksIDLabels(ctx context.Context, params *GetChecksIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostChecksIDLabels calls the POST on /checks/{checkID}/labels
func (c *Client) PostChecksIDLabels(ctx context.Context, params *PostChecksIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteChecksIDLabelsID calls the DELETE on /checks/{checkID}/labels/{labelID}
func (c *Client) DeleteChecksIDLabelsID(ctx context.Context, params *DeleteChecksIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/checks/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetChecksIDQuery calls the GET on /checks/{checkID}/query
func (c *Client) GetChecksIDQuery(ctx context.Context, params *GetChecksIDQueryAllParams) (*FluxResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "checkID", runtime.ParamLocationPath, params.CheckID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checks/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FluxResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetDashboards calls the GET on /dashboards
func (c *Client) GetDashboards(ctx context.Context, params *GetDashboardsParams) (*Dashboards, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Descending != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Owner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner", runtime.ParamLocationQuery, *params.Owner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dashboards{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDashboardsID calls the DELETE on /dashboards/{dashboardID}
func (c *Client) DeleteDashboardsID(ctx context.Context, params *DeleteDashboardsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// PatchDashboardsID calls the PATCH on /dashboards/{dashboardID}
func (c *Client) PatchDashboardsID(ctx context.Context, params *PatchDashboardsIDAllParams) (*Dashboard, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dashboard{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDashboardsIDCells calls the POST on /dashboards/{dashboardID}/cells
func (c *Client) PostDashboardsIDCells(ctx context.Context, params *PostDashboardsIDCellsAllParams) (*Cell, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Cell{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutDashboardsIDCells calls the PUT on /dashboards/{dashboardID}/cells
func (c *Client) PutDashboardsIDCells(ctx context.Context, params *PutDashboardsIDCellsAllParams) (*Dashboard, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dashboard{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDashboardsIDCellsID calls the DELETE on /dashboards/{dashboardID}/cells/{cellID}
func (c *Client) DeleteDashboardsIDCellsID(ctx context.Context, params *DeleteDashboardsIDCellsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cellID", runtime.ParamLocationPath, params.CellID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// PatchDashboardsIDCellsID calls the PATCH on /dashboards/{dashboardID}/cells/{cellID}
func (c *Client) PatchDashboardsIDCellsID(ctx context.Context, params *PatchDashboardsIDCellsIDAllParams) (*Cell, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cellID", runtime.ParamLocationPath, params.CellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Cell{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetDashboardsIDCellsIDView calls the GET on /dashboards/{dashboardID}/cells/{cellID}/view
func (c *Client) GetDashboardsIDCellsIDView(ctx context.Context, params *GetDashboardsIDCellsIDViewAllParams) (*View, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cellID", runtime.ParamLocationPath, params.CellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells/%s/view", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &View{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchDashboardsIDCellsIDView calls the PATCH on /dashboards/{dashboardID}/cells/{cellID}/view
func (c *Client) PatchDashboardsIDCellsIDView(ctx context.Context, params *PatchDashboardsIDCellsIDViewAllParams) (*View, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cellID", runtime.ParamLocationPath, params.CellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/cells/%s/view", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &View{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetDashboardsIDLabels calls the GET on /dashboards/{dashboardID}/labels
func (c *Client) GetDashboardsIDLabels(ctx context.Context, params *GetDashboardsIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDashboardsIDLabels calls the POST on /dashboards/{dashboardID}/labels
func (c *Client) PostDashboardsIDLabels(ctx context.Context, params *PostDashboardsIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDashboardsIDLabelsID calls the DELETE on /dashboards/{dashboardID}/labels/{labelID}
func (c *Client) DeleteDashboardsIDLabelsID(ctx context.Context, params *DeleteDashboardsIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDashboardsIDMembers calls the GET on /dashboards/{dashboardID}/members
func (c *Client) GetDashboardsIDMembers(ctx context.Context, params *GetDashboardsIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDashboardsIDMembers calls the POST on /dashboards/{dashboardID}/members
func (c *Client) PostDashboardsIDMembers(ctx context.Context, params *PostDashboardsIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDashboardsIDMembersID calls the DELETE on /dashboards/{dashboardID}/members/{userID}
func (c *Client) DeleteDashboardsIDMembersID(ctx context.Context, params *DeleteDashboardsIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDashboardsIDOwners calls the GET on /dashboards/{dashboardID}/owners
func (c *Client) GetDashboardsIDOwners(ctx context.Context, params *GetDashboardsIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDashboardsIDOwners calls the POST on /dashboards/{dashboardID}/owners
func (c *Client) PostDashboardsIDOwners(ctx context.Context, params *PostDashboardsIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDashboardsIDOwnersID calls the DELETE on /dashboards/{dashboardID}/owners/{userID}
func (c *Client) DeleteDashboardsIDOwnersID(ctx context.Context, params *DeleteDashboardsIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dashboardID", runtime.ParamLocationPath, params.DashboardID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDBRPs calls the GET on /dbrps
func (c *Client) GetDBRPs(ctx context.Context, params *GetDBRPsParams) (*DBRPs, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dbrps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BucketID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucketID", runtime.ParamLocationQuery, *params.BucketID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Default != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Db != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "db", runtime.ParamLocationQuery, *params.Db); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Rp != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rp", runtime.ParamLocationQuery, *params.Rp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DBRPs{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDBRP calls the POST on /dbrps
func (c *Client) PostDBRP(ctx context.Context, params *PostDBRPAllParams) (*DBRP, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dbrps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DBRP{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDBRPID calls the DELETE on /dbrps/{dbrpID}
func (c *Client) DeleteDBRPID(ctx context.Context, params *DeleteDBRPIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dbrpID", runtime.ParamLocationPath, params.DbrpID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/dbrps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDBRPsID calls the GET on /dbrps/{dbrpID}
func (c *Client) GetDBRPsID(ctx context.Context, params *GetDBRPsIDAllParams) (*DBRPGet, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dbrpID", runtime.ParamLocationPath, params.DbrpID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dbrps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DBRPGet{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchDBRPID calls the PATCH on /dbrps/{dbrpID}
func (c *Client) PatchDBRPID(ctx context.Context, params *PatchDBRPIDAllParams) (*DBRPGet, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dbrpID", runtime.ParamLocationPath, params.DbrpID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dbrps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DBRPGet{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDelete calls the POST on /delete
func (c *Client) PostDelete(ctx context.Context, params *PostDeleteAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	queryValues := queryURL.Query()

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Bucket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucket", runtime.ParamLocationQuery, *params.Bucket); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BucketID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucketID", runtime.ParamLocationQuery, *params.BucketID); err != nil {
			return err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDocumentsTemplates calls the GET on /documents/templates
func (c *Client) GetDocumentsTemplates(ctx context.Context, params *GetDocumentsTemplatesParams) (*Documents, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Documents{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDocumentsTemplates calls the POST on /documents/templates
func (c *Client) PostDocumentsTemplates(ctx context.Context, params *PostDocumentsTemplatesAllParams) (*Document, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Document{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDocumentsTemplatesID calls the DELETE on /documents/templates/{templateID}
func (c *Client) DeleteDocumentsTemplatesID(ctx context.Context, params *DeleteDocumentsTemplatesIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetDocumentsTemplatesID calls the GET on /documents/templates/{templateID}
func (c *Client) GetDocumentsTemplatesID(ctx context.Context, params *GetDocumentsTemplatesIDAllParams) (*Document, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Document{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutDocumentsTemplatesID calls the PUT on /documents/templates/{templateID}
func (c *Client) PutDocumentsTemplatesID(ctx context.Context, params *PutDocumentsTemplatesIDAllParams) (*Document, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Document{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetDocumentsTemplatesIDLabels calls the GET on /documents/templates/{templateID}/labels
func (c *Client) GetDocumentsTemplatesIDLabels(ctx context.Context, params *GetDocumentsTemplatesIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostDocumentsTemplatesIDLabels calls the POST on /documents/templates/{templateID}/labels
func (c *Client) PostDocumentsTemplatesIDLabels(ctx context.Context, params *PostDocumentsTemplatesIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteDocumentsTemplatesIDLabelsID calls the DELETE on /documents/templates/{templateID}/labels/{labelID}
func (c *Client) DeleteDocumentsTemplatesIDLabelsID(ctx context.Context, params *DeleteDocumentsTemplatesIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, params.TemplateID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/documents/templates/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetFlags calls the GET on /flags
func (c *Client) GetFlags(ctx context.Context, params *GetFlagsParams) (*Flags, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Flags{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetHealth calls the GET on /health
func (c *Client) GetHealth(ctx context.Context, params *GetHealthParams) (*HealthCheck, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheck{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetLabels calls the GET on /labels
func (c *Client) GetLabels(ctx context.Context, params *GetLabelsParams) (*LabelsResponse, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostLabels calls the POST on /labels
func (c *Client) PostLabels(ctx context.Context, params *PostLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteLabelsID calls the DELETE on /labels/{labelID}
func (c *Client) DeleteLabelsID(ctx context.Context, params *DeleteLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetLabelsID calls the GET on /labels/{labelID}
func (c *Client) GetLabelsID(ctx context.Context, params *GetLabelsIDAllParams) (*LabelResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchLabelsID calls the PATCH on /labels/{labelID}
func (c *Client) PatchLabelsID(ctx context.Context, params *PatchLabelsIDAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetLegacyAuthorizations calls the GET on /legacy/authorizations
func (c *Client) GetLegacyAuthorizations(ctx context.Context, params *GetLegacyAuthorizationsParams) (*Authorizations, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userID", runtime.ParamLocationQuery, *params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Token != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AuthID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authID", runtime.ParamLocationQuery, *params.AuthID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorizations{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostLegacyAuthorizations calls the POST on /legacy/authorizations
func (c *Client) PostLegacyAuthorizations(ctx context.Context, params *PostLegacyAuthorizationsAllParams) (*Authorization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteLegacyAuthorizationsID calls the DELETE on /legacy/authorizations/{authID}
func (c *Client) DeleteLegacyAuthorizationsID(ctx context.Context, params *DeleteLegacyAuthorizationsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetLegacyAuthorizationsID calls the GET on /legacy/authorizations/{authID}
func (c *Client) GetLegacyAuthorizationsID(ctx context.Context, params *GetLegacyAuthorizationsIDAllParams) (*Authorization, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchLegacyAuthorizationsID calls the PATCH on /legacy/authorizations/{authID}
func (c *Client) PatchLegacyAuthorizationsID(ctx context.Context, params *PatchLegacyAuthorizationsIDAllParams) (*Authorization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Authorization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostLegacyAuthorizationsIDPassword calls the POST on /legacy/authorizations/{authID}/password
func (c *Client) PostLegacyAuthorizationsIDPassword(ctx context.Context, params *PostLegacyAuthorizationsIDPasswordAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authID", runtime.ParamLocationPath, params.AuthID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/legacy/authorizations/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetMe calls the GET on /me
func (c *Client) GetMe(ctx context.Context, params *GetMeParams) (*UserResponse, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutMePassword calls the PUT on /me/password
func (c *Client) PutMePassword(ctx context.Context, params *PutMePasswordAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/me/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetNotificationEndpoints calls the GET on /notificationEndpoints
func (c *Client) GetNotificationEndpoints(ctx context.Context, params *GetNotificationEndpointsParams) (*NotificationEndpoints, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, params.OrgID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationEndpoints{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// CreateNotificationEndpoint calls the POST on /notificationEndpoints
func (c *Client) CreateNotificationEndpoint(ctx context.Context, params *CreateNotificationEndpointAllParams) (*NotificationEndpoint, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationEndpoint{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteNotificationEndpointsID calls the DELETE on /notificationEndpoints/{endpointID}
func (c *Client) DeleteNotificationEndpointsID(ctx context.Context, params *DeleteNotificationEndpointsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetNotificationEndpointsID calls the GET on /notificationEndpoints/{endpointID}
func (c *Client) GetNotificationEndpointsID(ctx context.Context, params *GetNotificationEndpointsIDAllParams) (*NotificationEndpoint, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationEndpoint{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchNotificationEndpointsID calls the PATCH on /notificationEndpoints/{endpointID}
func (c *Client) PatchNotificationEndpointsID(ctx context.Context, params *PatchNotificationEndpointsIDAllParams) (*NotificationEndpoint, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationEndpoint{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutNotificationEndpointsID calls the PUT on /notificationEndpoints/{endpointID}
func (c *Client) PutNotificationEndpointsID(ctx context.Context, params *PutNotificationEndpointsIDAllParams) (*NotificationEndpoint, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationEndpoint{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetNotificationEndpointsIDLabels calls the GET on /notificationEndpoints/{endpointID}/labels
func (c *Client) GetNotificationEndpointsIDLabels(ctx context.Context, params *GetNotificationEndpointsIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostNotificationEndpointIDLabels calls the POST on /notificationEndpoints/{endpointID}/labels
func (c *Client) PostNotificationEndpointIDLabels(ctx context.Context, params *PostNotificationEndpointIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteNotificationEndpointsIDLabelsID calls the DELETE on /notificationEndpoints/{endpointID}/labels/{labelID}
func (c *Client) DeleteNotificationEndpointsIDLabelsID(ctx context.Context, params *DeleteNotificationEndpointsIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, params.EndpointID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/notificationEndpoints/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetNotificationRules calls the GET on /notificationRules
func (c *Client) GetNotificationRules(ctx context.Context, params *GetNotificationRulesParams) (*NotificationRules, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, params.OrgID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.CheckID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkID", runtime.ParamLocationQuery, *params.CheckID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationRules{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// CreateNotificationRule calls the POST on /notificationRules
func (c *Client) CreateNotificationRule(ctx context.Context, params *CreateNotificationRuleAllParams) (*NotificationRule, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationRule{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteNotificationRulesID calls the DELETE on /notificationRules/{ruleID}
func (c *Client) DeleteNotificationRulesID(ctx context.Context, params *DeleteNotificationRulesIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetNotificationRulesID calls the GET on /notificationRules/{ruleID}
func (c *Client) GetNotificationRulesID(ctx context.Context, params *GetNotificationRulesIDAllParams) (*NotificationRule, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationRule{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchNotificationRulesID calls the PATCH on /notificationRules/{ruleID}
func (c *Client) PatchNotificationRulesID(ctx context.Context, params *PatchNotificationRulesIDAllParams) (*NotificationRule, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationRule{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutNotificationRulesID calls the PUT on /notificationRules/{ruleID}
func (c *Client) PutNotificationRulesID(ctx context.Context, params *PutNotificationRulesIDAllParams) (*NotificationRule, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationRule{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetNotificationRulesIDLabels calls the GET on /notificationRules/{ruleID}/labels
func (c *Client) GetNotificationRulesIDLabels(ctx context.Context, params *GetNotificationRulesIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostNotificationRuleIDLabels calls the POST on /notificationRules/{ruleID}/labels
func (c *Client) PostNotificationRuleIDLabels(ctx context.Context, params *PostNotificationRuleIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteNotificationRulesIDLabelsID calls the DELETE on /notificationRules/{ruleID}/labels/{labelID}
func (c *Client) DeleteNotificationRulesIDLabelsID(ctx context.Context, params *DeleteNotificationRulesIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetNotificationRulesIDQuery calls the GET on /notificationRules/{ruleID}/query
func (c *Client) GetNotificationRulesIDQuery(ctx context.Context, params *GetNotificationRulesIDQueryAllParams) (*FluxResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleID", runtime.ParamLocationPath, params.RuleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationRules/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FluxResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetOrgs calls the GET on /orgs
func (c *Client) GetOrgs(ctx context.Context, params *GetOrgsParams) (*Organizations, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Descending != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userID", runtime.ParamLocationQuery, *params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Organizations{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostOrgs calls the POST on /orgs
func (c *Client) PostOrgs(ctx context.Context, params *PostOrgsAllParams) (*Organization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Organization{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteOrgsID calls the DELETE on /orgs/{orgID}
func (c *Client) DeleteOrgsID(ctx context.Context, params *DeleteOrgsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetOrgsID calls the GET on /orgs/{orgID}
func (c *Client) GetOrgsID(ctx context.Context, params *GetOrgsIDAllParams) (*Organization, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Organization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchOrgsID calls the PATCH on /orgs/{orgID}
func (c *Client) PatchOrgsID(ctx context.Context, params *PatchOrgsIDAllParams) (*Organization, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Organization{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetOrgsIDMembers calls the GET on /orgs/{orgID}/members
func (c *Client) GetOrgsIDMembers(ctx context.Context, params *GetOrgsIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostOrgsIDMembers calls the POST on /orgs/{orgID}/members
func (c *Client) PostOrgsIDMembers(ctx context.Context, params *PostOrgsIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteOrgsIDMembersID calls the DELETE on /orgs/{orgID}/members/{userID}
func (c *Client) DeleteOrgsIDMembersID(ctx context.Context, params *DeleteOrgsIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetOrgsIDOwners calls the GET on /orgs/{orgID}/owners
func (c *Client) GetOrgsIDOwners(ctx context.Context, params *GetOrgsIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostOrgsIDOwners calls the POST on /orgs/{orgID}/owners
func (c *Client) PostOrgsIDOwners(ctx context.Context, params *PostOrgsIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteOrgsIDOwnersID calls the DELETE on /orgs/{orgID}/owners/{userID}
func (c *Client) DeleteOrgsIDOwnersID(ctx context.Context, params *DeleteOrgsIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/orgs/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetOrgsIDSecrets calls the GET on /orgs/{orgID}/secrets
func (c *Client) GetOrgsIDSecrets(ctx context.Context, params *GetOrgsIDSecretsAllParams) (*SecretKeysResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretKeysResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchOrgsIDSecrets calls the PATCH on /orgs/{orgID}/secrets
func (c *Client) PatchOrgsIDSecrets(ctx context.Context, params *PatchOrgsIDSecretsAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/orgs/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// PostOrgsIDSecrets calls the POST on /orgs/{orgID}/secrets/delete
func (c *Client) PostOrgsIDSecrets(ctx context.Context, params *PostOrgsIDSecretsAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgID", runtime.ParamLocationPath, params.OrgID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/orgs/%s/secrets/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetPing calls the GET on /ping
func (c *Client) GetPing(ctx context.Context) error {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// HeadPing calls the HEAD on /ping
func (c *Client) HeadPing(ctx context.Context) error {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// PostQueryAnalyze calls the POST on /query/analyze
func (c *Client) PostQueryAnalyze(ctx context.Context, params *PostQueryAnalyzeAllParams) (*AnalyzeQueryResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query/analyze")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	if params.ContentType != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam1)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyzeQueryResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostQueryAst calls the POST on /query/ast
func (c *Client) PostQueryAst(ctx context.Context, params *PostQueryAstAllParams) (*ASTResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query/ast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	if params.ContentType != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam1)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ASTResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetQuerySuggestions calls the GET on /query/suggestions
func (c *Client) GetQuerySuggestions(ctx context.Context, params *GetQuerySuggestionsParams) (*FluxSuggestions, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query/suggestions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FluxSuggestions{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetQuerySuggestionsName calls the GET on /query/suggestions/{name}
func (c *Client) GetQuerySuggestionsName(ctx context.Context, params *GetQuerySuggestionsNameAllParams) (*FluxSuggestion, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, params.Name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query/suggestions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FluxSuggestion{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetReady calls the GET on /ready
func (c *Client) GetReady(ctx context.Context, params *GetReadyParams) (*Ready, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Ready{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostRestoreBucketMetadata calls the POST on /restore/bucket-metadata
func (c *Client) PostRestoreBucketMetadata(ctx context.Context, params *PostRestoreBucketMetadataAllParams) (*RestoredBucketMappings, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/bucket-metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoredBucketMappings{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetScrapers calls the GET on /scrapers
func (c *Client) GetScrapers(ctx context.Context, params *GetScrapersParams) (*ScraperTargetResponses, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScraperTargetResponses{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostScrapers calls the POST on /scrapers
func (c *Client) PostScrapers(ctx context.Context, params *PostScrapersAllParams) (*ScraperTargetResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScraperTargetResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteScrapersID calls the DELETE on /scrapers/{scraperTargetID}
func (c *Client) DeleteScrapersID(ctx context.Context, params *DeleteScrapersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/scrapers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetScrapersID calls the GET on /scrapers/{scraperTargetID}
func (c *Client) GetScrapersID(ctx context.Context, params *GetScrapersIDAllParams) (*ScraperTargetResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScraperTargetResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchScrapersID calls the PATCH on /scrapers/{scraperTargetID}
func (c *Client) PatchScrapersID(ctx context.Context, params *PatchScrapersIDAllParams) (*ScraperTargetResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScraperTargetResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetScrapersIDLabels calls the GET on /scrapers/{scraperTargetID}/labels
func (c *Client) GetScrapersIDLabels(ctx context.Context, params *GetScrapersIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostScrapersIDLabels calls the POST on /scrapers/{scraperTargetID}/labels
func (c *Client) PostScrapersIDLabels(ctx context.Context, params *PostScrapersIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteScrapersIDLabelsID calls the DELETE on /scrapers/{scraperTargetID}/labels/{labelID}
func (c *Client) DeleteScrapersIDLabelsID(ctx context.Context, params *DeleteScrapersIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetScrapersIDMembers calls the GET on /scrapers/{scraperTargetID}/members
func (c *Client) GetScrapersIDMembers(ctx context.Context, params *GetScrapersIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostScrapersIDMembers calls the POST on /scrapers/{scraperTargetID}/members
func (c *Client) PostScrapersIDMembers(ctx context.Context, params *PostScrapersIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteScrapersIDMembersID calls the DELETE on /scrapers/{scraperTargetID}/members/{userID}
func (c *Client) DeleteScrapersIDMembersID(ctx context.Context, params *DeleteScrapersIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetScrapersIDOwners calls the GET on /scrapers/{scraperTargetID}/owners
func (c *Client) GetScrapersIDOwners(ctx context.Context, params *GetScrapersIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostScrapersIDOwners calls the POST on /scrapers/{scraperTargetID}/owners
func (c *Client) PostScrapersIDOwners(ctx context.Context, params *PostScrapersIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteScrapersIDOwnersID calls the DELETE on /scrapers/{scraperTargetID}/owners/{userID}
func (c *Client) DeleteScrapersIDOwnersID(ctx context.Context, params *DeleteScrapersIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scraperTargetID", runtime.ParamLocationPath, params.ScraperTargetID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/scrapers/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetSetup calls the GET on /setup
func (c *Client) GetSetup(ctx context.Context, params *GetSetupParams) (*IsOnboarding, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsOnboarding{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostSetup calls the POST on /setup
func (c *Client) PostSetup(ctx context.Context, params *PostSetupAllParams) (*OnboardingResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OnboardingResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostSignin calls the POST on /signin
func (c *Client) PostSignin(ctx context.Context, params *PostSigninParams) error {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/signin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// PostSignout calls the POST on /signout
func (c *Client) PostSignout(ctx context.Context, params *PostSignoutParams) error {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/signout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetSources calls the GET on /sources
func (c *Client) GetSources(ctx context.Context, params *GetSourcesParams) (*Sources, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sources{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostSources calls the POST on /sources
func (c *Client) PostSources(ctx context.Context, params *PostSourcesAllParams) (*Source, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Source{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteSourcesID calls the DELETE on /sources/{sourceID}
func (c *Client) DeleteSourcesID(ctx context.Context, params *DeleteSourcesIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, params.SourceID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetSourcesID calls the GET on /sources/{sourceID}
func (c *Client) GetSourcesID(ctx context.Context, params *GetSourcesIDAllParams) (*Source, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, params.SourceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Source{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchSourcesID calls the PATCH on /sources/{sourceID}
func (c *Client) PatchSourcesID(ctx context.Context, params *PatchSourcesIDAllParams) (*Source, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, params.SourceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Source{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetSourcesIDBuckets calls the GET on /sources/{sourceID}/buckets
func (c *Client) GetSourcesIDBuckets(ctx context.Context, params *GetSourcesIDBucketsAllParams) (*Buckets, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, params.SourceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Buckets{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetSourcesIDHealth calls the GET on /sources/{sourceID}/health
func (c *Client) GetSourcesIDHealth(ctx context.Context, params *GetSourcesIDHealthAllParams) (*HealthCheck, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, params.SourceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/health", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheck{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// ListStacks calls the GET on /stacks
func (c *Client) ListStacks(ctx context.Context, params *ListStacksParams) (*struct {
	Stacks *[]Stack `json:"stacks,omitempty"`
}, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, params.OrgID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StackID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stackID", runtime.ParamLocationQuery, *params.StackID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &struct {
		Stacks *[]Stack `json:"stacks,omitempty"`
	}{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// CreateStack calls the POST on /stacks
func (c *Client) CreateStack(ctx context.Context, params *CreateStackAllParams) (*Stack, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stack{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteStack calls the DELETE on /stacks/{stack_id}
func (c *Client) DeleteStack(ctx context.Context, params *DeleteStackAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack_id", runtime.ParamLocationPath, params.StackId)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, params.OrgID); err != nil {
		return err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// ReadStack calls the GET on /stacks/{stack_id}
func (c *Client) ReadStack(ctx context.Context, params *ReadStackAllParams) (*Stack, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack_id", runtime.ParamLocationPath, params.StackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stack{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// UpdateStack calls the PATCH on /stacks/{stack_id}
func (c *Client) UpdateStack(ctx context.Context, params *UpdateStackAllParams) (*Stack, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack_id", runtime.ParamLocationPath, params.StackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stack{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// UninstallStack calls the POST on /stacks/{stack_id}/uninstall
func (c *Client) UninstallStack(ctx context.Context, params *UninstallStackAllParams) (*Stack, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack_id", runtime.ParamLocationPath, params.StackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stacks/%s/uninstall", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stack{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTasks calls the GET on /tasks
func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams) (*Tasks, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Tasks{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTasks calls the POST on /tasks
func (c *Client) PostTasks(ctx context.Context, params *PostTasksAllParams) (*Task, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Task{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTasksID calls the DELETE on /tasks/{taskID}
func (c *Client) DeleteTasksID(ctx context.Context, params *DeleteTasksIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTasksID calls the GET on /tasks/{taskID}
func (c *Client) GetTasksID(ctx context.Context, params *GetTasksIDAllParams) (*Task, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Task{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchTasksID calls the PATCH on /tasks/{taskID}
func (c *Client) PatchTasksID(ctx context.Context, params *PatchTasksIDAllParams) (*Task, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Task{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTasksIDLabels calls the GET on /tasks/{taskID}/labels
func (c *Client) GetTasksIDLabels(ctx context.Context, params *GetTasksIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTasksIDLabels calls the POST on /tasks/{taskID}/labels
func (c *Client) PostTasksIDLabels(ctx context.Context, params *PostTasksIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTasksIDLabelsID calls the DELETE on /tasks/{taskID}/labels/{labelID}
func (c *Client) DeleteTasksIDLabelsID(ctx context.Context, params *DeleteTasksIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/tasks/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTasksIDLogs calls the GET on /tasks/{taskID}/logs
func (c *Client) GetTasksIDLogs(ctx context.Context, params *GetTasksIDLogsAllParams) (*Logs, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Logs{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTasksIDMembers calls the GET on /tasks/{taskID}/members
func (c *Client) GetTasksIDMembers(ctx context.Context, params *GetTasksIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTasksIDMembers calls the POST on /tasks/{taskID}/members
func (c *Client) PostTasksIDMembers(ctx context.Context, params *PostTasksIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTasksIDMembersID calls the DELETE on /tasks/{taskID}/members/{userID}
func (c *Client) DeleteTasksIDMembersID(ctx context.Context, params *DeleteTasksIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/tasks/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTasksIDOwners calls the GET on /tasks/{taskID}/owners
func (c *Client) GetTasksIDOwners(ctx context.Context, params *GetTasksIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTasksIDOwners calls the POST on /tasks/{taskID}/owners
func (c *Client) PostTasksIDOwners(ctx context.Context, params *PostTasksIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTasksIDOwnersID calls the DELETE on /tasks/{taskID}/owners/{userID}
func (c *Client) DeleteTasksIDOwnersID(ctx context.Context, params *DeleteTasksIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/tasks/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTasksIDRuns calls the GET on /tasks/{taskID}/runs
func (c *Client) GetTasksIDRuns(ctx context.Context, params *GetTasksIDRunsAllParams) (*Runs, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AfterTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "afterTime", runtime.ParamLocationQuery, *params.AfterTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BeforeTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "beforeTime", runtime.ParamLocationQuery, *params.BeforeTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Runs{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTasksIDRuns calls the POST on /tasks/{taskID}/runs
func (c *Client) PostTasksIDRuns(ctx context.Context, params *PostTasksIDRunsAllParams) (*Run, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Run{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTasksIDRunsID calls the DELETE on /tasks/{taskID}/runs/{runID}
func (c *Client) DeleteTasksIDRunsID(ctx context.Context, params *DeleteTasksIDRunsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runID", runtime.ParamLocationPath, params.RunID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/tasks/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTasksIDRunsID calls the GET on /tasks/{taskID}/runs/{runID}
func (c *Client) GetTasksIDRunsID(ctx context.Context, params *GetTasksIDRunsIDAllParams) (*Run, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runID", runtime.ParamLocationPath, params.RunID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Run{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTasksIDRunsIDLogs calls the GET on /tasks/{taskID}/runs/{runID}/logs
func (c *Client) GetTasksIDRunsIDLogs(ctx context.Context, params *GetTasksIDRunsIDLogsAllParams) (*Logs, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskID", runtime.ParamLocationPath, params.TaskID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runID", runtime.ParamLocationPath, params.RunID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s/runs/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Logs{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTelegrafPlugins calls the GET on /telegraf/plugins
func (c *Client) GetTelegrafPlugins(ctx context.Context, params *GetTelegrafPluginsParams) (*TelegrafPlugins, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegraf/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TelegrafPlugins{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTelegrafs calls the GET on /telegrafs
func (c *Client) GetTelegrafs(ctx context.Context, params *GetTelegrafsParams) (*Telegrafs, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Telegrafs{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTelegrafs calls the POST on /telegrafs
func (c *Client) PostTelegrafs(ctx context.Context, params *PostTelegrafsAllParams) (*Telegraf, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Telegraf{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTelegrafsID calls the DELETE on /telegrafs/{telegrafID}
func (c *Client) DeleteTelegrafsID(ctx context.Context, params *DeleteTelegrafsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTelegrafsID calls the GET on /telegrafs/{telegrafID}
func (c *Client) GetTelegrafsID(ctx context.Context, params *GetTelegrafsIDAllParams) (*Telegraf, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Telegraf{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutTelegrafsID calls the PUT on /telegrafs/{telegrafID}
func (c *Client) PutTelegrafsID(ctx context.Context, params *PutTelegrafsIDAllParams) (*Telegraf, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Telegraf{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetTelegrafsIDLabels calls the GET on /telegrafs/{telegrafID}/labels
func (c *Client) GetTelegrafsIDLabels(ctx context.Context, params *GetTelegrafsIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTelegrafsIDLabels calls the POST on /telegrafs/{telegrafID}/labels
func (c *Client) PostTelegrafsIDLabels(ctx context.Context, params *PostTelegrafsIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTelegrafsIDLabelsID calls the DELETE on /telegrafs/{telegrafID}/labels/{labelID}
func (c *Client) DeleteTelegrafsIDLabelsID(ctx context.Context, params *DeleteTelegrafsIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTelegrafsIDMembers calls the GET on /telegrafs/{telegrafID}/members
func (c *Client) GetTelegrafsIDMembers(ctx context.Context, params *GetTelegrafsIDMembersAllParams) (*ResourceMembers, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMembers{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTelegrafsIDMembers calls the POST on /telegrafs/{telegrafID}/members
func (c *Client) PostTelegrafsIDMembers(ctx context.Context, params *PostTelegrafsIDMembersAllParams) (*ResourceMember, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceMember{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTelegrafsIDMembersID calls the DELETE on /telegrafs/{telegrafID}/members/{userID}
func (c *Client) DeleteTelegrafsIDMembersID(ctx context.Context, params *DeleteTelegrafsIDMembersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetTelegrafsIDOwners calls the GET on /telegrafs/{telegrafID}/owners
func (c *Client) GetTelegrafsIDOwners(ctx context.Context, params *GetTelegrafsIDOwnersAllParams) (*ResourceOwners, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwners{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostTelegrafsIDOwners calls the POST on /telegrafs/{telegrafID}/owners
func (c *Client) PostTelegrafsIDOwners(ctx context.Context, params *PostTelegrafsIDOwnersAllParams) (*ResourceOwner, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceOwner{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteTelegrafsIDOwnersID calls the DELETE on /telegrafs/{telegrafID}/owners/{userID}
func (c *Client) DeleteTelegrafsIDOwnersID(ctx context.Context, params *DeleteTelegrafsIDOwnersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "telegrafID", runtime.ParamLocationPath, params.TelegrafID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/telegrafs/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// ExportTemplate calls the POST on /templates/export
func (c *Client) ExportTemplate(ctx context.Context, params *ExportTemplateAllParams) (*Template, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Template{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetUsers calls the GET on /users
func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams) (*Users, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Users{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostUsers calls the POST on /users
func (c *Client) PostUsers(ctx context.Context, params *PostUsersAllParams) (*UserResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteUsersID calls the DELETE on /users/{userID}
func (c *Client) DeleteUsersID(ctx context.Context, params *DeleteUsersIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetUsersID calls the GET on /users/{userID}
func (c *Client) GetUsersID(ctx context.Context, params *GetUsersIDAllParams) (*UserResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchUsersID calls the PATCH on /users/{userID}
func (c *Client) PatchUsersID(ctx context.Context, params *PatchUsersIDAllParams) (*UserResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostUsersIDPassword calls the POST on /users/{userID}/password
func (c *Client) PostUsersIDPassword(ctx context.Context, params *PostUsersIDPasswordAllParams) error {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, params.UserID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/users/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetVariables calls the GET on /variables
func (c *Client) GetVariables(ctx context.Context, params *GetVariablesParams) (*Variables, error) {
	var err error

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Org != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrgID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgID", runtime.ParamLocationQuery, *params.OrgID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Variables{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostVariables calls the POST on /variables
func (c *Client) PostVariables(ctx context.Context, params *PostVariablesAllParams) (*Variable, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Variable{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteVariablesID calls the DELETE on /variables/{variableID}
func (c *Client) DeleteVariablesID(ctx context.Context, params *DeleteVariablesIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

// GetVariablesID calls the GET on /variables/{variableID}
func (c *Client) GetVariablesID(ctx context.Context, params *GetVariablesIDAllParams) (*Variable, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Variable{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PatchVariablesID calls the PATCH on /variables/{variableID}
func (c *Client) PatchVariablesID(ctx context.Context, params *PatchVariablesIDAllParams) (*Variable, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Variable{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PutVariablesID calls the PUT on /variables/{variableID}
func (c *Client) PutVariablesID(ctx context.Context, params *PutVariablesIDAllParams) (*Variable, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Variable{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// GetVariablesIDLabels calls the GET on /variables/{variableID}/labels
func (c *Client) GetVariablesIDLabels(ctx context.Context, params *GetVariablesIDLabelsAllParams) (*LabelsResponse, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelsResponse{}

	switch rsp.StatusCode {
	case 200:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// PostVariablesIDLabels calls the POST on /variables/{variableID}/labels
func (c *Client) PostVariablesIDLabels(ctx context.Context, params *PostVariablesIDLabelsAllParams) (*LabelResponse, error) {
	var err error
	var bodyReader io.Reader
	buf, err := json.Marshal(params.Body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	bodyBytes, err := ioutil.ReadAll(rsp.Body)

	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LabelResponse{}

	switch rsp.StatusCode {
	case 201:
		if err := unmarshalJSONResponse(bodyBytes, &response); err != nil {
			return nil, err
		}
	default:
		var serverError Error
		if err := unmarshalJSONResponse(bodyBytes, &serverError); err != nil {
			return nil, err
		}
		return nil, serverError.Error()
	}
	return response, nil

}

// DeleteVariablesIDLabelsID calls the DELETE on /variables/{variableID}/labels/{labelID}
func (c *Client) DeleteVariablesIDLabelsID(ctx context.Context, params *DeleteVariablesIDLabelsIDAllParams) error {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableID", runtime.ParamLocationPath, params.VariableID)
	if err != nil {
		return err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "labelID", runtime.ParamLocationPath, params.LabelID)
	if err != nil {
		return err
	}

	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return err
	}

	operationPath := fmt.Sprintf("/variables/%s/labels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return err
	}

	if params.ZapTraceSpan != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Zap-Trace-Span", runtime.ParamLocationHeader, *params.ZapTraceSpan)
		if err != nil {
			return err
		}

		req.Header.Set("Zap-Trace-Span", headerParam0)
	}

	req = req.WithContext(ctx)
	rsp, err := c.Client.Do(req)
	if err != nil {
		return err
	}

	defer func() { _ = rsp.Body.Close() }()

	return nil

}

/*

 */
